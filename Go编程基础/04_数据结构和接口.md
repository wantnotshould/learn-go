# 04_数据结构和接口

## 1. **数组和切片**

### 1.1 **数组**

Go中的数组是固定长度的容器，它的长度在声明时就已确定，并且在数组创建后不可改变。数组的元素必须是相同类型的。

**定义数组**：

```go
var arr [5]int // 定义一个包含5个整数的数组
arr[0] = 1     // 给第一个元素赋值
arr[1] = 2     // 给第二个元素赋值
fmt.Println(arr) // 输出: [1 2 0 0 0]
```

* 数组的长度是数组类型的一部分，因此如果你声明了`[5]int`类型的数组，它与`[6]int`类型的数组是不同的类型。
* 数组是值类型，当你将数组传递给函数时，数组会被复制，修改副本不会影响原数组。

**数组的遍历**：

```go
arr := [3]int{1, 2, 3}
for i := 0; i < len(arr); i++ {
    fmt.Println(arr[i]) // 输出数组的每个元素
}
```

### 1.2 **切片**

切片是对数组的抽象，它比数组更灵活。切片没有固定长度，可以动态增加或减少其大小。切片本质上是一个指向数组的指针，可以认为它是一个轻量级的动态数组。

**定义切片**：

```go
s := []int{1, 2, 3}  // 使用字面量定义切片
fmt.Println(s)        // 输出: [1 2 3]
```

**切片的长度和容量**：

* **长度**：切片中元素的数量。
* **容量**：从切片的起始位置到切片的末尾数组的元素数量。

```go
s := []int{1, 2, 3}
fmt.Println(len(s))  // 输出: 3
fmt.Println(cap(s))  // 输出: 3（此例中长度与容量相同）
```

**向切片添加元素**：

使用`append`函数可以向切片添加元素。`append`会返回一个新的切片（如果原切片容量不足，可能会重新分配一个新的底层数组）。

```go
s = append(s, 4)     // 向切片添加元素
fmt.Println(s)        // 输出: [1 2 3 4]
```

**切片的复制**：

可以使用`copy`函数来复制切片的数据。

```go
s1 := []int{1, 2, 3}
s2 := make([]int, len(s1))
copy(s2, s1)         // 将s1的元素复制到s2中
fmt.Println(s2)      // 输出: [1 2 3]
```

## 2. **映射（map）**

Go的`map`是一种无序的集合类型，它将键映射到值，类似于Python中的字典或Java中的哈希表。`map`的键是唯一的，且可以通过键高效地访问对应的值。

**创建映射**：

```go
m := make(map[string]int) // 创建一个空的map，键是字符串类型，值是整型
m["one"] = 1              // 插入数据
fmt.Println(m["one"])     // 输出: 1
```

**遍历映射**：

使用`range`来遍历`map`的键值对。

```go
m := map[string]int{
    "a": 1,
    "b": 2,
    "c": 3,
}

for key, value := range m {
    fmt.Println(key, value)
}
// 输出:
// a 1
// b 2
// c 3
```

**删除元素**：

使用`delete`函数从映射中删除元素。

```go
delete(m, "b")  // 删除键为"b"的元素
fmt.Println(m)  // 输出: map[a:1 c:3]
```

**判断键是否存在**：

访问`map`时，如果键不存在，返回值类型的零值。你可以使用一个`ok`变量来判断键是否存在。

```go
value, ok := m["b"]
if ok {
    fmt.Println(value)
} else {
    fmt.Println("键不存在")
}
```

## 3. **结构体（struct）**

Go没有类，但有结构体（struct）。结构体是用于存储相关数据的复合类型，可以用来封装多个字段。

**定义结构体**：

```go
type Person struct {
    Name string
    Age  int
}

p := Person{Name: "Alice", Age: 30}
fmt.Println(p.Name) // 输出: Alice
fmt.Println(p.Age)  // 输出: 30
```

**结构体字段的零值**：

结构体字段有默认的零值，如果没有显式初始化字段，字段会使用其类型的零值。

```go
type Point struct {
    X, Y int
}

p := Point{} // 没有初始化，字段会有零值
fmt.Println(p) // 输出: {0 0}
```

**通过指针访问结构体**：

结构体可以通过指针传递，修改结构体字段时也可以使用指针来避免值传递带来的性能开销。

```go
p := &Person{Name: "Bob", Age: 25}
p.Age = 26 // 使用指针修改字段
fmt.Println(p) // 输出: &{Bob 26}
```

**结构体方法**：

你可以为结构体定义方法，方法接收者可以是结构体的值或指针。

```go
func (p Person) Greet() {
    fmt.Println("Hello, my name is", p.Name)
}

p := Person{Name: "Charlie"}
p.Greet() // 输出: Hello, my name is Charlie
```

## 4. **接口（interface）**

Go中的接口是一种类型，它定义了一组方法。任何类型只要实现了接口中的方法，就自动实现了该接口，而不需要显式声明。

#### 4.1 **接口的定义和使用**

```go
type Speaker interface {
    Speak() string
}

type Person struct {
    Name string
}

func (p Person) Speak() string {
    return "Hello, my name is " + p.Name
}

func greet(s Speaker) {
    fmt.Println(s.Speak())
}

p := Person{Name: "Alice"}
greet(p) // 输出: Hello, my name is Alice
```

* 接口的实现是隐式的，不需要显式声明。
* 接口类型可以接受任何实现了它的方法集的类型。

### 4.2 **空接口（interface{}）**

空接口`interface{}`可以存储任何类型的值，因为它不要求实现任何方法。

```go
var any interface{}
any = 42
fmt.Println(any) // 输出: 42

any = "Hello"
fmt.Println(any) // 输出: Hello
```

空接口常用于实现类似“任意类型”的参数，广泛应用于标准库中的许多地方。

### 4.3 **类型断言**

类型断言用于从接口类型中提取具体的类型。如果断言成功，则返回值和`true`；否则，返回`false`。

```go
var a interface{} = "Hello, Go"

str, ok := a.(string)
if ok {
    fmt.Println(str) // 输出: Hello, Go
} else {
    fmt.Println("Not a string")
}
```

## 5. **Go的错误处理**

Go的错误处理是通过返回值来实现的，而不是通过异常机制。每个函数在可能失败的地方返回一个`error`类型的值，调用方检查这个`error`值来处理异常情况。

```go
import "fmt"
import "errors"

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

result, err := divide(10, 0)
if err != nil {
    fmt.Println("Error:", err) // 输出: Error: division by zero
} else {
    fmt.Println("Result:", result)
}
```

* `error`类型是一个内置接口，它有一个`Error()`方法，返回错误描述的字符串。
* 错误处理的惯例是检查`error`值，如果不为`nil`，则说明发生了错误。
