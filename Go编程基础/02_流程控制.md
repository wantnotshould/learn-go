# 02_流程控制

常见的流程控制语句包括：`if`、`for`、`switch`、`select`、`fallthrough`、`defer` 和 `goto`。

## 1. **`if` 语句**

`if` 语句是条件判断语句，语法如下：

```go
if 条件 {
    // 条件为真时执行
} else {
    // 条件为假时执行
}
```

### 示例：

```go
package main

import "fmt"

func main() {
    x := 10
    if x > 5 {
        fmt.Println("x 大于 5")
    } else {
        fmt.Println("x 小于或等于 5")
    }
}
```

### 结果：

```
x 大于 5
```

* `if` 语句用于判断某个条件是否成立，若成立则执行 `if` 块中的代码，否则执行 `else` 块中的代码。
* Go 语言中的 `if` 语句支持在 `if` 后面直接进行变量声明。

```go
if x := 10; x > 5 {
    fmt.Println("x 大于 5")
}
```

## 2. **`for` 循环**

`for` 是 Go 中唯一的循环语句，用于重复执行某段代码。它有三种不同的用法。

### (1) **传统的 `for` 循环**

```go
for 初始化语句; 条件表达式; 后操作 {
    // 循环体
}
```

### 示例：

```go
package main

import "fmt"

func main() {
    for i := 0; i < 5; i++ {
        fmt.Println(i)
    }
}
```

### 结果：

```
0
1
2
3
4
```

### (2) **`for` 循环的简化版：条件判断**

如果只写条件表达式，`for` 会变成一个类似于 `while` 的循环，持续执行直到条件为 `false`。

```go
i := 0
for i < 5 {
    fmt.Println(i)
    i++
}
```

### (3) **无限循环**

`for` 也可以用来创建无限循环，使用 `for` 后面没有任何条件。

```go
for {
    fmt.Println("无限循环")
}
```

### (4) **`for range` 循环**

`for range` 用于遍历数组、切片、映射、字符串等数据结构，返回每个元素的索引和值。

```go
// 遍历数组
arr := []int{1, 2, 3, 4}
for index, value := range arr {
    fmt.Println(index, value)
}
```

### 结果：

```
0 1
1 2
2 3
3 4
```

在遍历字符串时，`range` 返回每个字符的索引和对应的 Unicode 编码：

```go
str := "hello"
for index, char := range str {
    fmt.Printf("索引: %d, 字符: %c\n", index, char)
}
```

### 结果：

```
索引: 0, 字符: h
索引: 1, 字符: e
索引: 2, 字符: l
索引: 3, 字符: l
索引: 4, 字符: o
```

## 3. **`switch` 语句**

`switch` 语句用于多条件分支判断，根据变量的值执行不同的分支。Go 的 `switch` 语法很简洁，并且不会像其他语言那样需要显式的 `break`。

### 示例：

```go
package main

import "fmt"

func main() {
    x := 2
    switch x {
    case 1:
        fmt.Println("x 等于 1")
    case 2:
        fmt.Println("x 等于 2")
    case 3:
        fmt.Println("x 等于 3")
    default:
        fmt.Println("x 不是 1、2 或 3")
    }
}
```

### 结果：

```
x 等于 2
```

* `switch` 会根据 `x` 的值去匹配相应的 `case`，如果没有匹配项，则会执行 `default`（如果有的话）。
* Go 的 `switch` 语句不需要显式的 `break`，它会在匹配成功后自动跳出。

### (1) **多个条件**

一个 `case` 可以匹配多个条件，用逗号分隔。

```go
switch x {
case 1, 2, 3:
    fmt.Println("x 是 1、2 或 3")
default:
    fmt.Println("x 是其他值")
}
```

### (2) **条件表达式**

`switch` 中的 `case` 还可以是表达式，而不仅仅是常量。

```go
switch {
case x > 10:
    fmt.Println("x 大于 10")
case x < 5:
    fmt.Println("x 小于 5")
default:
    fmt.Println("x 介于 5 和 10 之间")
}
```

## 4. **`select` 语句**

`select` 语句是 Go 中专门用于并发编程的语句，用来在多个 `channel` 操作中进行选择。它与 `switch` 语法相似，但它的 `case` 是 `channel` 操作。

### 示例：

```go
package main

import (
    "fmt"
    "time"
)

func sendData(ch chan string) {
    time.Sleep(2 * time.Second)
    ch <- "数据发送完毕"
}

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    go sendData(ch1)
    go sendData(ch2)

    select {
    case msg1 := <-ch1:
        fmt.Println("收到来自 ch1 的消息:", msg1)
    case msg2 := <-ch2:
        fmt.Println("收到来自 ch2 的消息:", msg2)
    case <-time.After(3 * time.Second):
        fmt.Println("等待超时")
    }
}
```

### 结果：

```
等待超时
```

或：

```
收到来自 ch1 的消息: 数据发送完毕
```

### 说明：

* `select` 可以在多个 `channel` 上等待，直到其中一个 `channel` 准备好。
* 如果没有任何 `channel` 准备好，`select` 会阻塞，直到有一个 `case` 可以执行。
* 可以使用 `time.After()` 来设置超时机制，避免 `select` 一直阻塞。

## 5. **`fallthrough` 语句**

Go 的 `switch` 语句默认不会跳到下一个 `case`，除非显式使用 `fallthrough`。

### 示例：

```go
package main

import "fmt"

func main() {
    x := 2
    switch x {
    case 1:
        fmt.Println("x 等于 1")
    case 2:
        fmt.Println("x 等于 2")
        fallthrough
    case 3:
        fmt.Println("x 等于 3")
    default:
        fmt.Println("x 不是 1、2 或 3")
    }
}
```

### 结果：

```
x 等于 2
x 等于 3
```

* 使用 `fallthrough`，当 `case` 满足条件时，它会继续执行下一个 `case` 语句的代码。

## 6. **`defer` 语句**

`defer` 语句用于在函数执行结束时延迟执行某个操作，常用于资源清理（例如关闭文件、解锁互斥锁等）。

### 示例：

```go
package main

import "fmt"

func main() {
    defer fmt.Println("Deferred Call")
    fmt.Println("Main function")
}
```

### 结果：

```
Main function
Deferred Call
```

* `defer` 语句会在函数执行完成后被执行，不管函数是正常结束还是因错误退出。

## 7. **`goto` 语句**

`goto` 语句用于无条件地跳转到指定的标签位置。其基本语法是：

```go
goto 标签
```

### 示例：

```go
package main

import "fmt"

func main() {
    i := 0
    Loop:
    fmt.Println(i)
    i++
    if i < 5 {
        goto Loop  // 跳转回标签 Loop
    }
}
```

### 结果：

```
0
1
2
3
4
```

在上面的例子中，`goto Loop` 语句使程序跳回 `Loop` 标签位置，直到条件 `i < 5` 不成立为止。

### 注意：

* **`goto` 语句必须跳转到函数内的标签位置，且标签后面不能是表达式**。
* `goto` 的使用要谨慎，过度使用会使得代码的控制流变得混乱，难以理解和维护。
下面是包含 `continue` 语句的完整流程控制语句的整理：


## 8. **`continue`**

语句**

`continue` 语句用于跳过当前循环中的剩余代码，直接进入下一次循环的判断条件。

### 示例：

```go
package main

import "fmt"

func main() {
    for i := 0; i < 5; i++ {
        if i == 2 {
            continue // 跳过当前迭代，直接进入下一次循环
        }
        fmt.Println(i)
    }
}
```

### 结果：

```
0
1
3
4
```

* 当 `i == 2` 时，`continue` 会跳过当前迭代，直接进入下一次循环，因此不会打印 `2`。
