# 02_流程控制

[control.go](../gobasic/control/control.go)

## **if**

`if` 语句用于根据条件判断是否执行某段代码。如果条件为真，则执行大括号内的代码。

```go
if x > 0 {
    return y
}
```

可以在 `if` 语句中初始化变量，且变量的作用域仅限于 `if` 语句块。

```go
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
```

`if` 语句常用于错误处理，检查是否发生了错误。

```go
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
```

## **for**

`for` 是 Go 唯一的循环结构。它通常包含初始化语句、条件判断和迭代语句。

```go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
```

`for` 循环也可以用于遍历集合类型（如 `map` 和 `array`）。

```go
for key, value := range oldMap {
    newMap[key] = value
}
```

可以只使用 `range` 语句中的 `key` 来遍历 `map` 的键，并根据条件删除元素。

```go
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
```

通过 `range` 遍历数组时，可以忽略索引值，只处理数组中的元素。

```go
sum := 0
for _, value := range array {
    sum += value
}
```

## **switch**

`switch` 语句用于多条件判断，它可以简化多重 `if-else` 结构，并支持多种形式的条件判断。

```go
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
```

`switch` 语句也支持常规值匹配，例如：

```go
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
```

## **type switch**

`type switch` 是用于检查变量的动态类型，它将变量的类型与不同的类型案例进行比较。

```go
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("unexpected type %T\n", t)     // %T prints whatever type t has
case bool:
    fmt.Printf("boolean %t\n", t)             // t has type bool
case int:
    fmt.Printf("integer %d\n", t)             // t has type int
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t has type *bool
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t has type *int
}
```
