# 03_并发编程练习题

[exercises.go](../gobasic/exercises/exercises.go)

### 1. **简单的并发计数器**

编写一个简单的并发计数器。启动 10 个 goroutine，每个 goroutine 增加一个计数器的值 1000 次，最后打印出计数器的最终值。

**目标：**

* 使用 `sync/atomic` 或 `sync.Mutex` 来确保对计数器的并发访问是安全的。
* 保证最终结果应该是 10,000。

### 2. **生产者消费者模式**

实现一个生产者消费者模式。创建两个 goroutine：

* 生产者向一个共享的缓冲通道中放入数据。
* 消费者从该通道中取出数据并处理。

**要求：**

* 使用通道进行同步，确保消费者在生产者没有数据时阻塞，生产者在消费者满的时候阻塞。
* 使用 `sync.WaitGroup` 等同步机制来确保主 goroutine 等待 goroutine 完成。

### 3. **并发求和**

编写一个程序，将一个大数组分成多个部分并使用多个 goroutine 来并行计算数组的和。然后将结果汇总。

**目标：**

* 将一个大数组分割成多个部分，每个部分由一个独立的 goroutine 计算总和。
* 最终汇总所有部分的和并输出。

### 4. **读取并发锁**

编写一个程序，模拟多个 goroutine 并发读取一个共享资源。使用 `sync.RWMutex` 来保证多个读取者可以并行读取，但在有写入者时需要加锁。

**要求：**

* 使用 `sync.RWMutex` 来实现多个 goroutine 同时读取共享资源，而在写操作时，所有其他操作都应该等待。
* 保证写操作时，读取操作会被阻塞。

### 5. **并发文件下载**

编写一个程序，通过多个 goroutine 来并发下载文件。假设你需要从多个 URL 下载文件，利用 goroutine 来并行下载这些文件，最后等待所有文件下载完成。

**要求：**

* 使用 `sync.WaitGroup` 来确保所有下载操作完成。
* 使用通道来传递下载进度或者错误信息。
* 可以选择使用 `http.Get` 来进行文件下载。

### 6. **并发排序**

实现一个并发的排序程序。你可以将一个大的数组分割成多个子数组并使用 goroutine 对每个子数组进行排序，最后将这些排序好的子数组合并成一个有序数组。

**目标：**

* 使用并发来分割和排序数据。
* 使用 `sync.WaitGroup` 来确保所有的子数组都被排序完成。

### 7. **并发实现 Web 服务器**

用 Go 实现一个简单的 Web 服务器，能够处理并发请求。服务器需要处理多个客户端的请求，并使用 goroutine 为每个请求提供服务。

**要求：**

* 使用 `net/http` 包创建 HTTP 服务器。
* 服务器能够同时处理多个请求。
* 可以选择使用 `sync/WaitGroup` 来确保主程序等待所有请求完成。

### 8. **读写并发模拟**

编写一个程序，模拟并发读写数据的情形。你有一个共享数据，多个读者和写者会同时访问它，写者会修改数据，而读者只读数据。

**要求：**

* 使用 `sync.RWMutex` 来实现并发读写。
* 写者和读者的操作需要并发执行。

### 9. **限流器实现**

实现一个基于 Go 的限流器。每次允许最多 3 个并发请求处理，超过的请求需要等待。

**目标：**

* 使用通道或 `sync/Mutex` 来控制最大并发数。
* 对请求进行限流，确保在同一时刻只有 3 个请求被处理。

### 10. **并发日志记录**

编写一个程序，模拟并发环境下的日志记录。多个 goroutine 会同时记录日志，需要确保日志输出顺序和线程安全。

**要求：**

* 使用 `sync.Mutex` 来确保每次只有一个 goroutine 可以写日志。
* 输出日志到标准输出或者文件，确保不会丢失任何日志信息。

### 11. **并发游戏模拟**

编写一个程序模拟一个简单的多人游戏。在游戏中，每个玩家都在一个 goroutine 中，玩家可以同时进行一些操作（例如移动、攻击等），游戏服务器（主 goroutine）需要协调这些操作并进行合并。

**目标：**

* 通过并发模拟多名玩家进行实时游戏操作。
* 使用通道和 `sync.WaitGroup` 来协调玩家间的通信。