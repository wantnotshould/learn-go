# 05_并发编程

## 1. **Goroutine**

### 1.1 **什么是Goroutine？**

Goroutine是Go语言中的轻量级线程。它由Go运行时（runtime）管理，创建和销毁的成本比操作系统线程低。每个Goroutine都会在并发环境下执行，它们之间相互独立，可以并行工作。

* Goroutine的创建非常简单，只需在函数前加上`go`关键字即可。
* Goroutine是并发执行的，它的执行顺序是不可预测的。

### 1.2 **启动Goroutine**

启动一个Goroutine非常简单，通过在函数调用前加上`go`关键字。

```go
go func() {
    fmt.Println("Hello from a Goroutine!")
}()
```

这段代码会创建一个新的Goroutine来执行匿名函数。主程序不会等待Goroutine完成，它会继续执行其他代码。

### 1.3 **Goroutine的并发执行**

多个Goroutine是并发执行的，执行顺序是不可控的。你可以启动多个Goroutine来并发执行不同的任务。

```go
go func() {
    fmt.Println("Task 1")
}()
go func() {
    fmt.Println("Task 2")
}()
```

在上述代码中，`Task 1`和`Task 2`是并发执行的。你不能确定哪个任务先执行。

### 1.4 **Goroutine的生命周期**

Goroutine的生命周期由Go运行时管理，主程序会等待所有的Goroutine完成后才会退出。为了控制程序退出时所有Goroutine完成，我们可以使用**同步机制**。

## 2. **Channel**

### 2.1 **什么是Channel？**

Channel是Go语言中的一种数据结构，它用于在不同的Goroutine之间传递数据。Channel类似于一个管道，Goroutines通过它发送和接收数据。

* Channel是类型安全的，发送到Channel的数据类型必须与Channel声明的类型一致。
* Channel可以是有缓冲的（Buffered）或无缓冲的（Unbuffered）。

### 2.2 **创建Channel**

创建Channel时，你需要指定它的类型。可以使用`make`函数创建一个Channel。

```go
ch := make(chan int)  // 创建一个传递整数类型数据的无缓冲Channel
```

### 2.3 **发送和接收数据**

* 通过`<-`运算符向Channel发送数据或从Channel接收数据。

**发送数据到Channel**：

```go
ch <- 1  // 发送整数1到Channel
```

**从Channel接收数据**：

```go
value := <-ch  // 从Channel接收数据
```

**示例：**

```go
ch := make(chan int)

go func() {
    ch <- 42  // 向Channel发送数据
}()

value := <-ch  // 从Channel接收数据
fmt.Println(value)  // 输出: 42
```

### 2.4 **无缓冲和有缓冲Channel**

* **无缓冲Channel**：数据发送和接收必须同步，发送方和接收方必须同时准备好才能完成操作。适用于需要同步的场景。
* **有缓冲Channel**：Channel具有缓冲区，数据可以在缓冲区中存储，发送方不需要等待接收方。

**有缓冲Channel的创建**：

```go
ch := make(chan int, 2)  // 创建一个缓冲区大小为2的Channel
ch <- 1                  // 向Channel发送数据
ch <- 2                  // 向Channel发送数据
fmt.Println(<-ch)        // 输出: 1
fmt.Println(<-ch)        // 输出: 2
```

在有缓冲的Channel中，发送方不需要等待接收方。如果Channel的缓冲区已满，发送方会阻塞直到有空间。

### 2.5 **关闭Channel**

在使用完Channel后，应该关闭Channel，表示没有更多的数据会被发送到Channel。可以使用`close()`函数关闭Channel。

```go
close(ch)  // 关闭Channel
```

关闭的Channel仍然可以接收数据，但不能再向其中发送数据。

```go
ch := make(chan int)
go func() {
    for i := 0; i < 3; i++ {
        ch <- i
    }
    close(ch)  // 关闭Channel
}()

for value := range ch {
    fmt.Println(value)  // 输出: 0 1 2
}
```

## 3. **select语句**

### 3.1 **什么是select语句？**

`select`语句是Go中的一个控制结构，用于等待多个Channel的操作。它类似于`switch`语句，但每个`case`语句用于操作一个Channel。

* `select`会随机选择一个准备好的Channel进行操作。
* 如果多个Channel都准备好，`select`会随机选择一个执行。
* 如果没有Channel准备好，`select`会阻塞直到某个Channel准备好。

### 3.2 **使用select**

```go
ch1 := make(chan int)
ch2 := make(chan int)

go func() {
    ch1 <- 1
}()
go func() {
    ch2 <- 2
}()

select {
case msg1 := <-ch1:
    fmt.Println("Received from ch1:", msg1)
case msg2 := <-ch2:
    fmt.Println("Received from ch2:", msg2)
}
```

在这个例子中，`select`会等待`ch1`和`ch2`中任意一个Channel准备好，然后接收数据。输出顺序是不确定的。

### 3.3 **默认case**

`select`语句支持`default`分支，用于在没有任何Channel准备好的情况下执行某个操作。

```go
ch := make(chan int)

select {
case msg := <-ch:
    fmt.Println("Received:", msg)
default:
    fmt.Println("No message received")
}
```

如果没有Channel准备好，`select`会执行`default`分支中的代码。

## 4. **Goroutine同步**

由于Goroutine是并发执行的，很多时候我们需要同步它们的操作。Go提供了几种同步机制，如`sync.WaitGroup`和`sync.Mutex`。

### 4.1 **WaitGroup**

`sync.WaitGroup`用于等待一组Goroutine完成。在你需要等待多个Goroutine完成时，可以使用`Add`、`Done`和`Wait`方法来管理。

```go
var wg sync.WaitGroup

wg.Add(2)  // 设置等待计数器为2

go func() {
    defer wg.Done()  // 完成时调用Done
    fmt.Println("Goroutine 1")
}()

go func() {
    defer wg.Done()  // 完成时调用Done
    fmt.Println("Goroutine 2")
}()

wg.Wait()  // 等待所有Goroutine完成
```

### 4.2 **Mutex（互斥锁）**

`sync.Mutex`用于保护临界区，防止多个Goroutine同时访问共享资源。

```go
var mu sync.Mutex
var count int

go func() {
    mu.Lock()   // 获取锁
    count++
    mu.Unlock() // 释放锁
}()

go func() {
    mu.Lock()   // 获取锁
    count++
    mu.Unlock() // 释放锁
}()
```

`Lock`会在同一时刻只允许一个Goroutine访问临界区，其他Goroutine需要等待。

## 5. **并发设计模式**

在Go中，常见的并发设计模式包括：

### 5.1 **生产者-消费者模式**

在生产者-消费者模式中，生产者Goroutine生成数据，消费者Goroutine消费数据。通过Channel进行数据的传递。

```go
func producer(ch chan int) {
    for i := 0; i < 5; i++ {
        ch <- i
        fmt.Println("Produced:", i)
    }
    close(ch)
}

func consumer(ch chan int) {
    for item := range ch {
        fmt.Println("Consumed:", item)
    }
}

ch := make(chan int)
go producer(ch)
go consumer(ch)
time.Sleep(time.Second)  // 等待Goroutines完成
```

### 5.2 **工作池模式**

工作池模式用于管理多个Goroutine来执行任务。通过限制同时运行的Goroutine数量，可以避免系统过载。

```go
type Job struct {
    ID int
}

func worker(id int, jobs <-chan Job, results chan<- string) {
    for job := range jobs {
        results <- fmt.Sprintf("Worker %d processed job %d", id, job.ID)
    }
}

func main() {
    jobs := make(chan Job, 10)
    results := make(chan string, 10)

    // 启动多个工作Goroutine
    for i := 1; i <=  3; i++ {
        go worker(i, jobs, results)
    }

    // 创建任务
    for j := 1; j <= 5; j++ {
        jobs <- Job{ID: j}
    }

    // 关闭jobs通道
    close(jobs)

    // 获取结果
    for r := range results {
        fmt.Println(r)
    }
}

```

## 6. **总结**

- **Goroutine**：是Go中的轻量级线程，创建和销毁成本低，能够并发执行任务。
- **Channel**：是用于在Goroutine之间传递数据的管道，支持无缓冲和有缓冲两种类型。
- **select**：用于处理多个Channel的操作，支持`default`分支来避免阻塞。
- **同步机制**：`WaitGroup`用于等待Goroutine完成，`Mutex`用于保护临界区。
- **并发设计模式**：生产者-消费者模式和工作池模式等，帮助管理并发任务。
