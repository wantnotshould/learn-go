# 01_基础

[basic.go](../gobasic/basic/basic.go)

## Keywords

```text
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
```

## Types

### Boolean

```go
// 1字节 true/false 零值: false
var b bool
```

### Numeric

```text
uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE 754 32-bit floating-point numbers 精度大约是 6-7 位有效数字
float64     the set of all IEEE 754 64-bit floating-point numbers 精度大约是 15-16 位有效数字

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for uint8
rune        alias for int32
```

```text
uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
```

[numeric.go](../gobasic/basic/numeric.go)

### String

Go 语言中的基本类型，往往将字符串看作一个整体，但它实际上是一块连续的内容空间，可以理解成由字符组成的数组。

[string.go](../gobasic/basic/string.go)

### Array

一种**数据结构**，是相同类型元素组成的集合。在初始化之后`大小无法改变`，存储元素类型相同、大小相同才是同一类型。

[array.go](../gobasic/basic/array.go)

### Slice

动态数组，长度并不固定，我们可以向切片中追加元素，它会在容量不足时自动扩容。

```go
// 创建方法
// 下标，数组/切片的一部分
arr[0:3] or slice[0:3] // 截取数组或切片的第0到第3个元素（不包括第3个）

// 字面量
// 字面量形式的切片可以直接创建切片并初始化其内容
slice := []int{1,2,3}

// make 关键字
// 使用 make 创建的切片会分配一个动态的底层数组，并返回一个切换引用该数组
// length 切片中元素的数量
// capacity 从切片的起始位置到切片的末尾数组的元素数量
make([]T, length, capacity) // 返回一个初始化的切片、映射或通道
```

[slice.go](../gobasic/basic/slice.go)

### Struct

由一系列命名元素（字段）组成的序列，每个字段都有名称和类型。在结构体内部，非空字段名称必须唯一。

```go
// invalid struct types
type (
	T1 struct{ T1 }            // T1 contains a field of T1
	T2 struct{ f [10]T2 }      // T2 contains T2 as component of an array
	T3 struct{ T4 }            // T3 contains T3 as component of an array in struct T4
	T4 struct{ f [10]T3 }      // T4 contains T4 as component of struct T3 in an array
)

// valid struct types
type (
	T5 struct{ f *T5 }         // T5 contains T5 as component of a pointer
	T6 struct{ f func() T6 }   // T6 contains T6 as component of a function type
	T7 struct{ f [10][]T7 }    // T7 contains T7 as component of a slice in an array
)
```

[struct.go](../gobasic/basic/struct.go)

### Pointer

指针类型用于表示指向某种类型变量的指针。通过指针，可以间接访问或修改值，指针是由一个基础类型和指针符号`*`组成

* 指针类型 = `*` 基本类型
* 基本类型 = 任意类型（如 `int`, `string` 等）

零值：未初始化的指针类型的零值是 `nil`，表示它不指向任何有效的内存地址。

**相关符号**

* **`&`** 用于获取变量的内存地址
* **`*`** 用于解引用指针，访问指针指向的值

[pointer.go](../gobasic/basic/pointer.go)

### Function

函数类型是一种特殊的类型，表示具有指定参数和返回值的函数。函数类型可以用于定义变量、传递函数、返回函数等。

[function.go](../gobasic/basic/function.go)

### Interface

接口类型定义了一组方法签名。任何类型，只要实现了接口中定义的所有方法，就实现了该接口。

[interface.go](../gobasic/basic/interface.go)

### Map

map是一种无序的键值对集合，它通过键（key）来索引对应的值（value）。是哈希表实现的一种数据结构，具有快速查找，插入和删除的特点。

```go
// MapType = "map" "[" KeyType "]" ElementType .
// KeyType = Type .

map[string]int                // 键是字符串，值是整数
map[*T]struct{ x, y float64 } // 键是指向 T 类型的指针，值是一个包含两个浮点数的结构体
map[string]interface{}        // 键是字符串，值是任意类型（空接口）
```

[map.go](../gobasic/basic/map.go)

### Channel

channel 是一种用于 `goroutine` （并发执行的轻量级线程）之间传递数据的机制，它提供了一种安全的方式来进行同步和通信。

```text
chan ElementType        // 可用于发送和接收指定类型的值
chan<- ElementType      // 只可用于发送指定类型的值
<-chan ElementType      // 只可用于接收指定类型的值
```

**创建**

```go
ch := make(chan int)          // 无缓冲通道（发送和接收必须同步）
ch := make(chan int, 10)      // 有缓冲通道，缓冲区大小为 10
```

**发送和接收**

```go
ch := make(chan int)
ch <- 10  // 发送数据到通道
value := <-ch  // 从通道接收数据
```

**通道关闭**

通过 `close()` 函数可以关闭 `channel` ,表示通道不再接收数据，接收方可以通过接收操作判断是否已关闭。

```go
ch := make(chan int)
close(ch)  // 关闭通道
```

**多值接收**

```go
value, ok := <-ch  // ok 为 false 表示通道已关闭
```

**总结**

* 双向通道 `chan ElementType` 允许数据的 **发送** 和 **接收**
* 单向通道 `chan<- ElementType, <-chan ElementType` 用于限定通道只能发送或接收数据，用于函数签名或复杂的并发控制。
* 无缓冲通道：发送和接收操作必须同步，适合需要严格同步的场景。
* 有缓冲通道：允许数据在没有接收方的情况下被存储，发送方不会立即阻塞，适用于任务调度和流量控制。
* 通道的使用场景：goroutine 之间的通信、同步、工作池、select 多路复用、流量控制等。

[channel.go](../gobasic/basic/channel.go)


## Operators and punctuation

[operators.go](../gobasic/basic/operators.go)

```text
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=          ~
```

### 1. **算术运算符**

用于基本的数学计算：

* `+`：加法
* `-`：减法
* `*`：乘法
* `/`：除法（整型除法会截断结果）
* `%`：求余（取余数）

**例子**：

```go
fmt.Println("算术运算符：")
a := 10
b := 3
fmt.Println(a + b) // 加法
fmt.Println(a - b) // 减法
fmt.Println(a * b) // 乘法
fmt.Println(a / b) // 除法
fmt.Println(a % b) // 取余
```

### 2. **关系运算符**

用于比较两个值之间的关系：

* `==`：等于
* `!=`：不等于
* `>`：大于
* `<`：小于
* `>=`：大于或等于
* `<=`：小于或等于

**例子**：

```go
fmt.Println("\n关系运算符：")
a := 10
b := 5
fmt.Println(a == b) // 等于
fmt.Println(a != b) // 不等于
fmt.Println(a > b)  // 大于
fmt.Println(a < b)  // 小于
fmt.Println(a >= b) // 大于或等于
fmt.Println(a <= b) // 小于或等于
```

### 3. **逻辑运算符**

用于组合条件表达式：

* `&&`：逻辑与（AND）
* `||`：逻辑或（OR）
* `!`：逻辑非（NOT）

**例子**：

```go
fmt.Println("\n逻辑运算符：")
a := true
b := false
fmt.Println(a && b) // 与（AND）
fmt.Println(a || b) // 或（OR）
fmt.Println(!a)     // 非（NOT）
```

### 4. **位运算符**

用于整数的二进制位操作：

* `&`：按位与
* `|`：按位或
* `^`：按位异或
* `&^`：按位清除（A 和 B 对应位都为 1 时，A 结果为 0，B 结果为 1）
* `<<`：左移
* `>>`：右移

**例子**：

```go
fmt.Println("\n位运算符：")
a := 5  // 二进制：0101
b := 3  // 二进制：0011
fmt.Println(a & b)   // 输出 1  (0101 & 0011 = 0001)
fmt.Println(a | b)   // 输出 7  (0101 | 0011 = 0111)
fmt.Println(a ^ b)   // 输出 6  (0101 ^ 0011 = 0110)
fmt.Println(a &^ b)  // 输出 4  (0101 &^ 0011 = 0100)

fmt.Println(a << 1)  // 输出 10  (左移一位，0101 << 1 = 1010)
fmt.Println(a >> 1)  // 输出 2   (右移一位，0101 >> 1 = 0010)
```

### 5. **赋值运算符**

用于将一个值赋给变量，Go 支持不同形式的赋值运算符：

* `=`：普通赋值
* `+=`：加法赋值
* `-=`：减法赋值
* `*=`：乘法赋值
* `/=`：除法赋值
* `%=`：求余赋值
* `<<=`：左移赋值
* `>>=`：右移赋值
* `&=`：按位与赋值
* `|=`：按位或赋值
* `^=`：按位异或赋值
* `&^=`：按位清除赋值

**例子**：

```go
fmt.Println("\n赋值运算符：")
a := 5
a += 3         // a = a + 3
fmt.Println(a) // 输出 8

a *= 2         // a = a * 2
fmt.Println(a) // 输出 16

a >>= 2        // a = a >> 2 (右移 2 位)
fmt.Println(a) // 输出 4
```

### 6. **其他运算符**

* **`++`**：自增运算符，增加 1
* **`--`**：自减运算符，减少 1
* **`:=`**：声明并赋值（简短赋值运算符）
* **`,`**：多重赋值，用于同时赋值多个变量

**例子**：

```go
fmt.Println("\n其他运算符：")
a := 5
a++  // 自增
fmt.Println(a)  // 输出 6

b := 10
c := 20
b, c = c, b  // 多重赋值
fmt.Println(b, c)  // 输出 20 10
```

### 7. **条件运算符**

Go 没有三元运算符（`?:`），但可以使用 `if` 语句代替三元运算符的功能：

```go
fmt.Println("\n条件运算符：")
a := 10
result := 0
if a > 5 {
    result = 1  // 设为 1，如果 a 大于 5
} else {
    result = 0  // 否则设为 0
}
fmt.Println(result)  // 输出 1
```

### 8. 指针运算符

* **`&`** 获取一个变量的地址，返回指向该变量的指针。
* **`*`** 解引用指针，获取指针指向的值。
* **`*`** 也用于声明指针类型。

**示例**：

```go
fmt.Println("\n指针运算符：")
a := 10
p := &a  // p 是指向 a 的指针
fmt.Println(p)  // 输出 a 的地址
```

```go
fmt.Println("\n指针运算符：")
a := 10
p := &a         // p 是指向 a 的指针
fmt.Println(p)  // 输出 a 的地址
fmt.Println(*p) // 输出 a 的值，即 10
*p = 20         // 修改 a 的值，通过指针 p
fmt.Println(a)  // 输出 20
```

```go
var p *int  // p 是指向 int 类型的指针
```