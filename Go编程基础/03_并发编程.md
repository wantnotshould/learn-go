# 03_并发编程

Go 语言通过轻量级的协程（goroutines）和通道（channels）提供了强大的并发编程模型，以下是 Go 特有的并发编程概念与实践。

## 1. 并发编程的核心理念

Go 提供了一种独特的并发编程方法，鼓励通过**通信而不是共享内存**来实现并发。换句话说，Go 的并发模型鼓励使用**通道**来传递数据，而不是通过直接共享变量，避免了数据竞争（Data Race）。

### 核心原则：

**不要通过共享内存来进行通信，而是通过通信来共享内存。**

这种方式有助于简化并发程序的开发，使得程序易于理解且能避免常见的并发问题（例如数据竞争）。

## 2. Goroutine

在 Go 中，`goroutine` 是一个轻量级的线程，可以与其他 `goroutine` 并发执行，并共享同一个地址空间。`goroutine` 的创建成本非常低，只需要分配栈空间，并且栈会根据需要动态增长。

### 创建 `goroutine`：

使用 `go` 关键字调用一个函数，它会在新的 `goroutine` 中并发执行。

```go
go list.Sort()  // 并发执行 list.Sort()
```

### 示例：使用匿名函数启动 `goroutine`：

```go
go func() {
    time.Sleep(time.Second)
    fmt.Println("Hello from goroutine!")
}()
```

## 3. 通道 (Channels)

Go 中的通道（`channel`）是一个用于在 `goroutine` 之间传递数据的同步原语。通道有两种类型：

* **无缓冲通道**：发送者和接收者必须同时准备好，否则会阻塞。
* **有缓冲通道**：发送者和接收者可以不同时准备，发送者会先把数据存入缓冲区，直到缓冲区满。

### 创建通道：

```go
ch := make(chan int)  // 无缓冲通道
ch := make(chan int, 10)  // 有缓冲通道，容量为 10
```

### 发送与接收数据：

```go
ch <- 42  // 发送数据到通道
x := <-ch  // 从通道接收数据
```

### 示例：等待 `goroutine` 完成

```go
c := make(chan int)
go func() {
    list.Sort()
    c <- 1  // 发送信号
}()
<-c  // 等待排序完成
```

## 4. 使用通道进行资源管理

通道不仅用于数据传递，还可以用于同步和限制并发。比如，通过一个缓冲通道来限制并发的请求数量。

### 示例：并发处理请求

```go
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem <- 1  // 等待空位
    process(r)  // 处理请求
    <-sem  // 处理完成
}

func Serve(queue chan *Request) {
    for req := range queue {
        go handle(req)  // 并发处理
    }
}
```

## 5. Channel of Channels

Go 允许通道作为第一类值，这意味着我们可以通过通道传递其他通道，方便实现并发的多路复用。

### 示例：使用通道处理请求和响应

```go
type Request struct {
    args       []int
    f          func([]int) int
    resultChan chan int
}

request := &Request{[]int{3, 4, 5}, sum, make(chan int)}
clientRequests <- request
fmt.Printf("answer: %d\n", <-request.resultChan)
```

在服务器端，处理请求并返回结果：

```go
func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan <- req.f(req.args)
    }
}
```

## 6. 并行计算

Go 的并发模型还支持将计算任务并行化，利用多核 CPU 提高计算效率。

### 示例：并行计算向量元素

```go
type Vector []float64

func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i < n; i++ {
        v[i] += u.Op(v[i])
    }
    c <- 1  // 完成信号
}

func (v Vector) DoAll(u Vector) {
    c := make(chan int, numCPU)  // 使用缓冲通道
    for i := 0; i < numCPU; i++ {
        go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c)
    }
    for i := 0; i < numCPU; i++ {
        <-c  // 等待每个 goroutine 完成
    }
}
```

### 自动获取 CPU 核心数

```go
var numCPU = runtime.NumCPU()  // 获取系统的 CPU 核心数
```

## 7. Leaky Buffer 示例

Go 的并发模型使得一些非并发的思想也变得易于表达。例如，可以利用通道来实现一个漏斗式的缓冲池。

### 示例：客户端和服务器的缓冲池

```go
var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        select {
        case b = <-freeList:
        default:
            b = new(Buffer)
        }
        load(b)
        serverChan <- b
    }
}

func server() {
    for {
        b := <-serverChan
        process(b)
        select {
        case freeList <- b:
        default:
        }
    }
}
```

## 8. 总结

Go 的并发模型通过轻量级的 `goroutines` 和高效的通信机制 `channels`，简化了并发编程，避免了传统线程和锁带来的复杂性。通过使用通道进行资源管理，程序能够高效、优雅地处理并发任务，同时避免常见的并发问题，如数据竞争。

Go 的并发编程不仅适用于高并发场景，还能有效地进行并行计算，充分利用多核 CPU 提高性能。
